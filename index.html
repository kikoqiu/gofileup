<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>File Transfer</title>
    <style>
        :root {
            --thumbnail-width: 250px;
            --bg-color: #121212; --text-color: #e0e0e0; --primary-color: #007aff;
            --success-color: #34c759; --error-color: #ff3b30; --input-bg: #1c1c1e;
            --border-color: #2c2c2d; --bubble-bg: #2c2c2e; --bubble-self-bg: #007aff;
            --withdraw-color: #ff9500; --download-color: #5856d6; --hover-bg: rgba(255, 255, 255, 0.1);
        }
        html, body { margin: 0; padding: 0; height: 100%; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: var(--bg-color); color: var(--text-color); overflow: hidden; }
        .hidden { display: none !important; }

        /* Login View Styles */
        #login-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; box-sizing: border-box; }
        #login-form { display: flex; flex-direction: column; width: 100%; max-width: 320px; gap: 15px; }
        #login-form h1 { font-size: 2em; font-weight: 600; text-align: center; margin-bottom: 20px; color: var(--primary-color); }
        .input-group { display: flex; flex-direction: column; }
        .input-group label { font-size: 0.9em; margin-bottom: 5px; color: rgba(255,255,255,0.7); }
        .input-group input { padding: 12px 15px; border: 1px solid var(--border-color); background-color: var(--input-bg); color: var(--text-color); border-radius: 8px; font-size: 16px; outline: none; }
        .input-group input:focus { border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.3); }
        .options-group { display: flex; align-items: center; gap: 8px; }
        #login-btn { padding: 12px; background-color: var(--primary-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; }
        #login-btn:hover { opacity: 0.85; }
        #login-error { color: var(--error-color); text-align: center; margin-top: 10px; min-height: 1.2em; }

        /* App View Styles */
        #app-container { display: flex; flex-direction: column; height: 100%; }
        #header { padding: 10px 15px; background-color: var(--input-bg); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; position: relative; flex-shrink: 0; }
        #header h1 { font-size: 1.1em; margin: 0; font-weight: 600; }
        #header-buttons { display: flex; align-items: center; gap: 8px; }
        .header-btn { background: none; border: none; padding: 5px; cursor: pointer; }
        .header-btn svg { width: 24px; height: 24px; fill: var(--text-color); transition: fill 0.2s; }
        .header-btn:hover svg { fill: var(--primary-color); }
        #dropdown-menu { display: none; position: absolute; top: 100%; right: 15px; background-color: #2c2c2e; border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10; overflow: hidden; }
        #dropdown-menu a { display: block; padding: 10px 20px; color: var(--text-color); text-decoration: none; font-size: 0.9em; }
        #dropdown-menu a:hover { background-color: #3a3a3c; }
        #dropdown-menu a.danger { color: var(--error-color); }
        #message-list { flex-grow: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column-reverse; }
        .message-wrapper { display: flex; flex-direction: column; align-items: flex-start; margin-bottom: 12px; max-width: 85%; }
        .message-wrapper.self { align-items: flex-end; align-self: flex-end; }
        .message-item { max-width: 100%; padding: 10px 15px; border-radius: 18px; background-color: var(--bubble-bg); word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message-wrapper.self .message-item { background-color: var(--bubble-self-bg); color: white; }
        .message-content .filename { font-weight: bold; margin-bottom: 2px; }
        .message-content .thumbnail-container { margin-bottom: 8px; }
        .message-content .text-content { white-space: pre-wrap; }
        .filesize { font-size: 0.8em; color: rgba(255,255,255,0.6); margin-top: 4px; }
        .message-wrapper.self .filesize { color: rgba(255,255,255,0.8); }
        .progress-bar-container { height: 6px; background-color: rgba(0,0,0,0.2); border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .progress-bar { height: 100%; width: 0; background-color: white; opacity: 0.7; border-radius: 3px; transition: width 0.2s ease-out; }
        .status-text { font-size: 0.8em; margin-top: 4px; color: rgba(255,255,255,0.7); }
        .message-footer { display: flex; justify-content: flex-end; align-items: center; font-size: 0.75em; margin-top: 6px; }
        .message-wrapper .message-footer { color: rgba(255,255,255,0.7); }
        .message-wrapper.self .message-footer { color: rgba(255,255,255,0.8); }
        .footer-timestamp { margin-right: auto; }
        .footer-btn { background: none; border: none; cursor: pointer; padding: 4px; margin-left: 8px; font-size: 0.9em; border-radius: 4px; }
        .footer-btn:hover { background-color: var(--hover-bg); }
        .download-btn { color: var(--download-color); }
        .withdraw-btn { color: var(--withdraw-color); }
        .message-wrapper.self .download-btn { color: rgba(255,255,255,0.8); }
        .message-wrapper.self .withdraw-btn { color: rgba(255,255,255,0.8); }
        #controls { display: flex; align-items: flex-end; padding: 10px 15px; background-color: var(--input-bg); border-top: 1px solid var(--border-color); flex-shrink: 0; gap: 10px; }
        #attachment-btn { background: none; border: none; padding: 8px; cursor: pointer; }
        #attachment-btn svg { width: 28px; height: 28px; fill: var(--primary-color); }
        #input-wrapper { flex-grow: 1; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 18px; display: flex; align-items: flex-end; }
        #text-input { flex-grow: 1; padding: 10px 15px; border: none; background: transparent; color: var(--text-color); outline: none; resize: none; font-size: 16px; max-height: 120px; overflow-y: auto; }
        #send-btn { background: none; border: none; padding: 8px 15px 8px 8px; cursor: pointer; align-self: center; }
        #send-btn svg { width: 28px; height: 28px; fill: var(--primary-color); transition: transform 0.2s ease; }
        #send-btn.active svg { transform: scale(1.1); }
        #attachment-popover { display: none; position: fixed; bottom: 70px; left: 15px; background-color: #2c2c2e; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10; padding: 8px; }
        .popover-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-radius: 8px; }
        .popover-item:hover { background-color: #3a3a3c; }
        .popover-item svg { width: 24px; height: 24px; fill: var(--text-color); margin-right: 15px; }
        input[type="file"] { display: none; }
        .thumbnail-container { width: var(--thumbnail-width); max-width: 100%; cursor: pointer; border-radius: 12px; overflow: hidden; line-height: 0; }
        .thumbnail-container img { width: 100%; height: auto; display: block; }
        #image-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); z-index: 1000; align-items: center; justify-content: center; cursor: pointer; }
        #image-overlay img { max-width: 95%; max-height: 95%; object-fit: contain; border-radius: 8px; }
        @keyframes shimmer { 0% { background-position: -500px 0; } 100% { background-position: 500px 0; } }
        .thumbnail-placeholder { width: 100%; aspect-ratio: 4 / 3; border-radius: 12px; background-color: #1c1c1e; background-image: linear-gradient(90deg, #1c1c1e 0px, #2c2c2d 40px, #1c1c1e 80px); background-size: 600px; animation: shimmer 1.5s infinite linear; }
    </style>
</head>
<body>
<!-- Login View -->
<div id="login-container" class="hidden">
    <form id="login-form">
        <h1>File Transfer</h1>
        <div class="input-group">
            <label for="username-input">Username</label>
            <input type="text" id="username-input" name="username" required autocomplete="username">
        </div>
        <div class="input-group">
            <label for="password-input">Password</label>
            <input type="password" id="password-input" name="password" required autocomplete="current-password">
        </div>
        <div class="options-group">
            <input type="checkbox" id="remember-me-checkbox">
            <label for="remember-me-checkbox">Remember me</label>
        </div>
        <button type="submit" id="login-btn">Login</button>
        <p id="login-error"></p>
    </form>
</div>

<!-- App View -->
<div id="app-container" class="hidden">
    <div id="header">
        <h1 data-i18n="headerTitle">File Transfer</h1>
        <div id="header-buttons">
            <button id="refresh-btn" class="header-btn" data-i18n-title="refreshBtnTitle">
                <svg viewBox="0 0 24 24"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" /></svg>
            </button>
            <button id="menu-btn" class="header-btn" data-i18n-title="menuBtnTitle">
                <svg viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>
            </button>
        </div>
        <div id="dropdown-menu">
            <a href="#" id="clear-records-btn" class="danger" data-i18n="clearRecordsBtn">Clear Records</a>
            <a href="#" id="logout-btn" data-i18n="logoutBtn">Logout</a>
        </div>
    </div>
    <div id="message-list"></div>
    <div id="controls">
        <button id="attachment-btn" data-i18n-title="attachmentBtnTitle">
            <svg viewBox="0 0 24 24"><path d="M12,18A6,6 0 0,1 6,12C6,8.69 8.69,6 12,6A6,6 0 0,1 18,12C18,15.31 15.31,18 12,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,10.5A1.5,1.5 0 0,0 10.5,12A1.5,1.5 0 0,0 12,13.5A1.5,1.5 0 0,0 13.5,12A1.5,1.5 0 0,0 12,10.5Z" /></svg>
        </button>
        <div id="input-wrapper">
            <textarea id="text-input" rows="1" data-i18n-placeholder="textInputPlaceholder"></textarea>
            <button id="send-btn" data-i18n-title="sendBtnTitle">
                <svg viewBox="0 0 24 24"><path d="M2,21L23,12L2,3V10L17,12L2,14V21Z" /></svg>
            </button>
        </div>
    </div>
</div>
<div id="attachment-popover">
    <div class="popover-item" id="upload-image-btn">
        <svg viewBox="0 0 24 24"><path d="M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19M8.5,13.5L11,16.5L14.5,12L19,18H5L8.5,13.5Z" /></svg>
        <span data-i18n="uploadImage">Image</span>
    </div>
    <div class="popover-item" id="upload-file-btn">
        <svg viewBox="0 0 24 24"><path d="M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18H6V20H15V18M18,15H6V17H18V15Z" /></svg>
        <span data-i18n="uploadFile">File</span>
    </div>
</div>
<input type="file" id="image-picker" accept="image/*" multiple>
<input type="file" id="file-picker" multiple>
<div id="image-overlay">
    <img id="fullscreen-image" src="" alt="Fullscreen Image Preview">
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- i18n Setup ---
    const translations = {
        en: {
            headerTitle: "File Transfer", logoutBtn: "Logout", refreshBtnTitle: "Refresh Messages", menuBtnTitle: "Menu", clearRecordsBtn: "Clear Records", attachmentBtnTitle: "Attach", uploadImage: "Image", uploadFile: "File", textInputPlaceholder: "Type something...", sendBtnTitle: "Send", confirmClearRecords: "Are you sure you want to clear all local message records? This action cannot be undone.", withdraw: "Withdraw", withdrawing: "Withdrawing...", download: "Download", uploading: "Uploading...", withdrawFailed: "Withdraw failed!", confirmLocalDelete: "The file may not exist on the server.\n\nDelete this record locally anyway?", defaultTextFilename: "TextMessage", uploadFailed: "Upload Failed"
        },
        zh: {
            headerTitle: "文件传输", logoutBtn: "退出登录", refreshBtnTitle: "刷新消息", menuBtnTitle: "菜单", clearRecordsBtn: "清空记录", attachmentBtnTitle: "附件", uploadImage: "图片", uploadFile: "文件", textInputPlaceholder: "输入文本...", sendBtnTitle: "发送", confirmClearRecords: "确定要清空所有本地消息记录吗？此操作不可恢复。", withdraw: "撤回", withdrawing: "撤回中...", download: "下载", uploading: "正在上传...", withdrawFailed: "撤回失败！", confirmLocalDelete: "服务器可能已不存在该文件。\n\n是否仅从本地删除此条记录？", defaultTextFilename: "文本消息", uploadFailed: "上传失败"
        }
    };
    const userLang = navigator.language.slice(0, 2);
    const lang = translations[userLang] ? userLang : 'en';
    const t = (key) => translations[lang][key] || key;
    function applyStaticTranslations() {
        document.title = t('headerTitle');
        document.querySelectorAll('[data-i18n]').forEach(el => el.innerText = t(el.dataset.i18n));
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => el.placeholder = t(el.dataset.i18nPlaceholder));
        document.querySelectorAll('[data-i18n-title]').forEach(el => el.title = t(el.dataset.i18nTitle));
    }

    // --- Element Selectors ---
    const loginContainer = document.getElementById('login-container');
    const loginForm = document.getElementById('login-form');
    const usernameInput = document.getElementById('username-input');
    const passwordInput = document.getElementById('password-input');
    const rememberMeCheckbox = document.getElementById('remember-me-checkbox');
    const loginError = document.getElementById('login-error');
    const logoutBtn = document.getElementById('logout-btn');
    const appContainer = document.getElementById('app-container');
    const messageList = document.getElementById('message-list');
    const attachmentBtn = document.getElementById('attachment-btn');
    const attachmentPopover = document.getElementById('attachment-popover');
    const imageBtn = document.getElementById('upload-image-btn');
    const fileBtn = document.getElementById('upload-file-btn');
    const sendBtn = document.getElementById('send-btn');
    const textInput = document.getElementById('text-input');
    const imagePicker = document.getElementById('image-picker');
    const filePicker = document.getElementById('file-picker');
    const menuBtn = document.getElementById('menu-btn');
    const dropdownMenu = document.getElementById('dropdown-menu');
    const clearRecordsBtn = document.getElementById('clear-records-btn');
    const refreshBtn = document.getElementById('refresh-btn');
    const imageOverlay = document.getElementById('image-overlay');
    const fullscreenImage = document.getElementById('fullscreen-image');

    // --- App State & Storage Keys ---
    let currentUser = null;
    const OLD_STORAGE_KEY = 'mobile-upload-messages';
    const CREDENTIALS_KEY = 'file-transfer-credentials';
    const LAST_USER_KEY = 'last-active-user';
    let saveTimeout = null;

    // --- View Management ---
    const showLoginView = () => {
        currentUser = null;
        appContainer.classList.add('hidden');
        loginContainer.classList.remove('hidden');
        passwordInput.value = '';
        messageList.innerHTML = '';
        loginError.textContent = '';
    };

    const showAppView = (username) => {
        currentUser = username;
        loginError.textContent = '';
        loginContainer.classList.add('hidden');
        appContainer.classList.remove('hidden');
    };

    // --- API & Auth ---
    const apiFetch = async (url, options = {}) => {
        const response = await fetch(url, options);
        if (response.status === 401) {
            showLoginView();
            throw new Error('Unauthorized');
        }
        return response;
    };

    // --- Storage Management ---
    const getStorageKey = () => currentUser ? `messages-${currentUser}` : null;
    
    const saveMessagesNow = (messages) => {
        const key = getStorageKey();
        if (!key) return;
        try {
            localStorage.setItem(key, JSON.stringify(messages));
        } catch (e) { console.error("Failed to save messages immediately:", e); }
    };

    const scheduleSave = (messages) => {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => saveMessagesNow(messages), 5000);
    };

    const storage = {
        getMessages: () => {
            const key = getStorageKey();
            if (!key) return [];
            const now = Date.now();
            const twentyNineDaysAgo = now - 29 * 24 * 60 * 60 * 1000;
            try {
                const messages = JSON.parse(localStorage.getItem(key) || '[]');
                const recentMessages = messages.filter(m => m.timestamp > twentyNineDaysAgo);
                if (messages.length !== recentMessages.length) {
                    saveMessagesNow(recentMessages);
                }
                return recentMessages;
            } catch (e) { return []; }
        },
        addMessage: (message) => { 
            const msgs = storage.getMessages(); 
            msgs.push(message); 
            saveMessagesNow(msgs); 
        },
        updateMessage: (id, updates) => {
            const msgs = storage.getMessages();
            const index = msgs.findIndex(m => m.id === id);
            if (index !== -1) { 
                msgs[index] = { ...msgs[index], ...updates }; 
                saveMessagesNow(msgs); 
            }
        },
        removeMessage: (id) => { 
            let msgs = storage.getMessages(); 
            msgs = msgs.filter(m => m.id !== id); 
            saveMessagesNow(msgs);
        },
        clearAll: () => {
            const key = getStorageKey();
            if (!key) return;
            clearTimeout(saveTimeout);
            localStorage.removeItem(key);
        },
        updateMessageDimensions: (id, { width, height }) => {
            const msgs = storage.getMessages();
            const index = msgs.findIndex(m => m.id === id);
            if (index !== -1) {
                msgs[index] = { ...msgs[index], width, height };
                scheduleSave(msgs);
            }
        }
    };
    
    const migrateOldStorage = () => {
        const oldData = localStorage.getItem(OLD_STORAGE_KEY);
        const newKey = getStorageKey();
        if (oldData && newKey) {
            console.log(`Migrating data from old key to new key: ${newKey}`);
            const newData = localStorage.getItem(newKey);
            if (!newData || JSON.parse(newData).length === 0) {
                localStorage.setItem(newKey, oldData);
            }
            localStorage.removeItem(OLD_STORAGE_KEY);
        }
    };

    // --- Utils & UI ---
    const formatTimestamp = (ts) => {
        const d = new Date(ts);
        return `${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')} ${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}`;
    };
    const formatBytes = (bytes, decimals = 2) => {
        if (!+bytes) return '0 Bytes';
        const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
    };
    const escapeHTML = (str) => str.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/'/g, '\'');
    const generateFilenameFromText = (text) => {
        const lines = text.split('\n'); let name = ''; const regex = /[<>:"/\\|?*\s]/g;
        for (const line of lines) { const sanitized = line.replace(regex, ''); if (sanitized.length > 0) { name = sanitized.substring(0, 20); break; } }
        return name || t('defaultTextFilename');
    };
    const scrollToBottom = () => { messageList.scrollTop = 0; };
    
    const renderMessage = (msg) => {
        const isSelf = msg.direction !== 'in';
        const isImage = msg.isImage || (msg.fileName && /\.(jpe?g|png|gif|webp)$/i.test(msg.fileName));
        let contentHtml;
        if (isImage && msg.status === 'success' && msg.filePath) {
            const previewUrl = `/preview/${msg.filePath}`; 
            const sizeHtml = msg.size ? `<div class="filesize">${formatBytes(msg.size)}</div>` : '';
            let placeholderStyle = '';
            if (msg.width && msg.height) {
                placeholderStyle = `style="aspect-ratio: ${msg.width} / ${msg.height}"`;
            }
            contentHtml = `
                <div class="thumbnail-container" data-src="${previewUrl}">
                    <div class="thumbnail-placeholder" ${placeholderStyle}></div>
                </div>
                <div class="filename">${escapeHTML(msg.fileName)}</div>
                ${sizeHtml}`;
        } else if (msg.isText) {
            let textToDisplay = msg.content;
            if (textToDisplay.split('\n').length > 8 || textToDisplay.length > 100) { textToDisplay = textToDisplay.substring(0, 100) + '...'; }
            contentHtml = `<div class="text-content">${escapeHTML(textToDisplay).replace(/\n/g, '<br>')}</div>`;
        } else {
            const sizeHtml = msg.size ? `<div class="filesize">${formatBytes(msg.size)}</div>` : '';
            contentHtml = `<div class="filename">${escapeHTML(msg.fileName || msg.content)}</div>${sizeHtml}`;
        }
        let footerHtml = '';
        if (msg.status === 'success') {
            const timeStr = formatTimestamp(msg.timestamp);
            const downloadBtn = `<button class="footer-btn download-btn" data-path="${msg.filePath}" title="${t('download')}">${t('download')}</button>`;
            const withdrawBtn = `<button class="footer-btn withdraw-btn" data-id="${msg.id}" data-path="${msg.filePath}" title="${t('withdraw')}">${t('withdraw')}</button>`;
            footerHtml = `<div class="message-footer"><span class="footer-timestamp">${timeStr}</span>${downloadBtn}${withdrawBtn}</div>`;
        }
        const progressHtml = msg.status === 'pending' ? `<div class="status-text">${t('uploading')} 0%</div><div class="progress-bar-container"><div class="progress-bar"></div></div>` : '';
        const errorHtml = msg.status === 'error' ? `<div class="message-footer"><span style="color:var(--error-color);">${t('uploadFailed')}</span></div>` : '';
        const messageHtml = `<div class="message-wrapper ${isSelf ? 'self' : ''}" id="${msg.id}">
            <div class="message-item ${msg.status || 'success'}">
                <div class="message-content">${contentHtml}</div>
                ${progressHtml}${footerHtml}${errorHtml}
            </div>
        </div>`;
        messageList.insertAdjacentHTML('afterbegin', messageHtml);
    };

    const lazyLoadObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const container = entry.target;
                const imageUrl = container.dataset.src;
                const image = new Image();
                image.dataset.fullscreenUrl = imageUrl;
                apiFetch(imageUrl).then(response => response.blob()).then(blob => {
                    image.src = URL.createObjectURL(blob);
                }).catch(err => {
                    if (err.message !== 'Unauthorized') console.error("Error lazy-loading image:", err);
                });
                image.alt = "Image preview";
                image.onload = () => {
                    URL.revokeObjectURL(image.src);
                    container.innerHTML = '';
                    container.appendChild(image);
                    const wrapper = container.closest('.message-wrapper');
                    if (wrapper) {
                        const msgId = wrapper.id;
                        const msg = storage.getMessages().find(m => m.id === msgId);
                        if (msg && (msg.width !== image.naturalWidth || msg.height !== image.naturalHeight)) {
                           storage.updateMessageDimensions(msgId, { width: image.naturalWidth, height: image.naturalHeight });
                        }
                    }
                };
                observer.unobserve(container);
            }
        });
    }, { root: messageList, rootMargin: "0px 0px 200px 0px" });

    const reRenderAllMessages = () => {
        if (!currentUser) return;
        lazyLoadObserver.disconnect();
        messageList.innerHTML = '';
        storage.getMessages().sort((a, b) => a.timestamp - b.timestamp).forEach(renderMessage);
        const placeholders = document.querySelectorAll('.thumbnail-container[data-src]');
        placeholders.forEach(ph => lazyLoadObserver.observe(ph));
        scrollToBottom();
    };

    // --- Core Logic ---
    const fetchAndMergeHistory = async () => {
        if (!currentUser) return;
        try {
            refreshBtn.firstElementChild.style.animation = 'spin 1s linear infinite';
            const response = await apiFetch('/history');
            const serverHistory = await response.json(); const localMessages = storage.getMessages();
            const serverFilePaths = new Set(serverHistory.map(m => m.filePath));
            let uiNeedsUpdate = false;
            const twentyNineDaysAgo = Date.now() - 29 * 24 * 60 * 60 * 1000;
            const messagesToDelete = [];
            localMessages.forEach(localMsg => {
                if (localMsg.status === 'success' && localMsg.filePath && localMsg.timestamp > twentyNineDaysAgo && !serverFilePaths.has(localMsg.filePath)) {
                    messagesToDelete.push(localMsg.id);
                }
            });
            if (messagesToDelete.length > 0) {
                messagesToDelete.forEach(id => storage.removeMessage(id));
                uiNeedsUpdate = true;
            }
            const updatedLocalMessages = storage.getMessages();
            const localFilePaths = new Set(updatedLocalMessages.map(m => m.filePath).filter(Boolean));
            serverHistory.forEach(serverMsg => {
                if (serverMsg.filePath && !localFilePaths.has(serverMsg.filePath)) {
                    storage.addMessage({
                        id: `msg-server-${serverMsg.timestamp}`, content: serverMsg.isText ? serverMsg.content : serverMsg.fileName,
                        fileName: serverMsg.fileName, size: serverMsg.size, isText: serverMsg.isText, status: 'success',
                        isImage: /\.(jpe?g|png|gif|webp)$/i.test(serverMsg.fileName),
                        timestamp: serverMsg.timestamp, filePath: serverMsg.filePath, direction: 'in'
                    });
                    uiNeedsUpdate = true;
                }
            });
            if (uiNeedsUpdate) reRenderAllMessages();
        } catch (error) {
            if (error.message !== 'Unauthorized') console.error("Error fetching or merging history:", error);
        } finally { 
            if(refreshBtn.firstElementChild) refreshBtn.firstElementChild.style.animation = ''; 
        }
    };

    const handleFiles = (files) => {
        if (!files.length) return; [...files].forEach(file => uploadFile(file));
        imagePicker.value = ''; filePicker.value = ''; attachmentPopover.style.display = 'none';
    };

    const handleSendText = () => {
        const text = textInput.value; if (!text.trim()) return;
        const baseName = generateFilenameFromText(text); const timeStr = new Date().toTimeString().slice(0, 8).replace(/:/g, '');
        const filename = `[${timeStr}]${baseName}.txt`; const textFile = new File([text], filename, { type: 'text/plain' });
        uploadFile(textFile, text); textInput.value = ''; textInput.style.height = 'auto'; sendBtn.classList.remove('active');
    };
    
    const uploadFile = (file, originalTextContent = null) => {
        const isText = originalTextContent !== null;
        const isImage = !isText && file.type.startsWith('image/');
        const message = {
            id: `msg-local-${Date.now()}-${Math.random()}`, content: isText ? originalTextContent : file.name,
            fileName: file.name, size: file.size, isText: isText, 
            isImage: isImage, status: 'pending', direction: 'out',
            timestamp: Date.now(), filePath: null
        };
        storage.addMessage(message);
        reRenderAllMessages();
        const msgEl = document.getElementById(message.id);
        const bar = msgEl?.querySelector('.progress-bar');
        const stat = msgEl?.querySelector('.status-text');
        const formData = new FormData(); formData.append('file', file); formData.append('isText', String(isText));
        if (isText) formData.append('textContent', originalTextContent);
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/upload', true);
        xhr.withCredentials = true; 
        xhr.upload.onprogress = (e) => {
            if (e.lengthComputable && bar) {
               const p = Math.round((e.loaded / e.total) * 100); bar.style.width = p + '%';
               if (stat) stat.textContent = `${t('uploading')} ${p}%`;
            }
        };
        xhr.onload = () => {
            if (xhr.status === 401) {
                showLoginView();
                return;
            }
            if (xhr.status === 200) {
                const res = JSON.parse(xhr.responseText);
                storage.updateMessage(message.id, { status: 'success', filePath: res.filePath, timestamp: Date.now() });
            } else {
                storage.updateMessage(message.id, { status: 'error' });
            }
            reRenderAllMessages();
        };
        xhr.onerror = () => { 
            storage.updateMessage(message.id, { status: 'error' });
            reRenderAllMessages(); 
        };
        xhr.send(formData);
    };

    // --- Event Listeners ---
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        loginError.textContent = '';
        const username = usernameInput.value;
        const password = passwordInput.value;
        try {
            const response = await fetch('/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            if (response.ok) {
                localStorage.setItem(LAST_USER_KEY, username); // Set the active user
                if (rememberMeCheckbox.checked) {
                    localStorage.setItem(CREDENTIALS_KEY, JSON.stringify({ username, password }));
                } else {
                    localStorage.removeItem(CREDENTIALS_KEY);
                }
                showAppView(username);
                migrateOldStorage();
                await initializeMainApp();
            } else {
                const data = await response.json();
                loginError.textContent = data.error || "Login failed.";
            }
        } catch (error) {
            loginError.textContent = "Network error. Could not connect to server.";
        }
    });

    logoutBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        try {
            await apiFetch('/logout', { method: 'POST' });
        } catch (error) {
            if (error.message !== 'Unauthorized') console.error('Logout API call failed, but logging out locally anyway.', error);
        } finally {
            localStorage.removeItem(LAST_USER_KEY);
            // Don't remove credentials on logout, user might want them for next login.
            showLoginView();
        }
    });
    refreshBtn.addEventListener('click', fetchAndMergeHistory);
    imageBtn.addEventListener('click', () => imagePicker.click());
    fileBtn.addEventListener('click', () => filePicker.click());
    imagePicker.addEventListener('change', (e) => handleFiles(e.target.files));
    filePicker.addEventListener('change', (e) => handleFiles(e.target.files));
    sendBtn.addEventListener('click', handleSendText);
    textInput.addEventListener('input', () => { textInput.style.height = 'auto'; textInput.style.height = textInput.scrollHeight + 'px'; sendBtn.classList.toggle('active', textInput.value.trim().length > 0); });
    attachmentBtn.addEventListener('click', (e) => { e.stopPropagation(); attachmentPopover.style.display = attachmentPopover.style.display === 'block' ? 'none' : 'block'; });
    menuBtn.addEventListener('click', (e) => { e.stopPropagation(); dropdownMenu.style.display = dropdownMenu.style.display === 'block' ? 'none' : 'block'; });
    clearRecordsBtn.addEventListener('click', () => { if (confirm(t('confirmClearRecords'))) { storage.clearAll(); reRenderAllMessages(); } dropdownMenu.style.display = 'none'; });
    
    imageOverlay.addEventListener('click', () => {
        imageOverlay.style.display = 'none';
        fullscreenImage.src = ''; 
    });
    
    document.addEventListener('click', () => { attachmentPopover.style.display = 'none'; dropdownMenu.style.display = 'none'; });
    
    messageList.addEventListener('click', async (e) => {
        const thumbnail = e.target.closest('.thumbnail-container img');
        if (thumbnail) {
            fullscreenImage.src = thumbnail.dataset.fullscreenUrl; 
            imageOverlay.style.display = 'flex';
            return;
        }
        const target = e.target.closest('button.footer-btn');        
        // NEW: Handle click on "Upload Failed" message to remove it.
        const errorFooter = e.target.closest('.message-footer');
        if (errorFooter && errorFooter.querySelector('[style*="var(--error-color)"]')) {
            const wrapper = e.target.closest('.message-wrapper');
            if (wrapper) {
                storage.removeMessage(wrapper.id);
                wrapper.remove();
            }
            return; // Stop further processing
        }
        if (!target) return;
        const id = target.dataset.id, path = target.dataset.path;
        if (target.classList.contains('download-btn')) { 
            window.location.href = `/download?path=${encodeURIComponent(path)}`; 
        }
        else if (target.classList.contains('withdraw-btn')) {
            target.disabled = true; target.textContent = t('withdrawing');
            try {
                await apiFetch('/delete', { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filePath: path }) });
                const localMessage = storage.getMessages().find(m => m.id === id);
                if(localMessage) storage.removeMessage(id);
                document.getElementById(id)?.remove();
            } catch (error) {
                if (error.message !== 'Unauthorized') {
                    console.error('Withdraw failed:', error);
                    if (confirm(t('withdrawFailed') + "\n\n" + t('confirmLocalDelete'))) {
                        storage.removeMessage(id);
                        document.getElementById(id)?.remove();
                    } else { target.disabled = false; target.textContent = t('withdraw'); }
                }
            }
        }
    });
    
    // --- Initial Load & Startup Logic ---
    const initializeMainApp = async () => {
        applyStaticTranslations(); 
        reRenderAllMessages(); 
        await fetchAndMergeHistory();
    };

    const startup = async () => {
        // Populate login form if credentials were saved (for convenience)
        const savedCreds = localStorage.getItem(CREDENTIALS_KEY);
        if (savedCreds) {
            try {
                const { username } = JSON.parse(savedCreds);
                usernameInput.value = username;
            } catch (e) {												  
                console.error("Could not parse saved credentials", e);
                localStorage.removeItem(CREDENTIALS_KEY);
            }
        }

        // Check for an active session by fetching history
        const lastUser = localStorage.getItem(LAST_USER_KEY);
        if (lastUser) {
            // Assume we are logged in as the last user and try to verify.
            currentUser = lastUser;
            try {
                await apiFetch('/history');
                // If it succeeds, the session is valid for `lastUser`.
                showAppView(lastUser);
                await initializeMainApp();
            } catch (error) {
                // apiFetch already handled the 401 by showing the login view.
                // It will also have cleared currentUser.
                if (error.message !== 'Unauthorized') {
                    console.error("Startup check failed:", error);
                    loginError.textContent = "Could not connect to server.";
                }
            }
        } else {
            // No last active user, must show login page.
            showLoginView();		 
        }
    };
    
    startup();

    const styleSheet = document.createElement("style");
    styleSheet.innerText = `@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }`;
    document.head.appendChild(styleSheet);
});
</script>
</body>
</html>